package com.familug.hvn;


import robocode.*;
import robocode.util.*;
import java.awt.*;

/**
 * SuperWalls - a sample robot by CrazyBassoonist based on the sample robot Walls by Mathew Nelson and maintained by Flemming N. Larsen
 * Moves around the outer edge with two targeting systems
 */
public class SuperWallsHeadFire extends AdvancedRobot {
	boolean movingForward;
	boolean gunIdent;       //Used to tell which gun we are using
	int dir = 1;
	double energy;
	static int enemyFireCount = 0;

	public void run() {
		setAdjustRadarForRobotTurn(true);
		setAdjustRadarForGunTurn(true);
		setBodyColor(Color.black);
		setGunColor(Color.black);
		setRadarColor(Color.white);
		setBulletColor(Color.cyan);
		setScanColor(Color.cyan);

		setTurnRadarRight(Double.POSITIVE_INFINITY);

		// turnLeft to face a wall.
		// getHeading() % 90 means the remainder of
		// getHeading() divided by 90.
		turnLeft(getHeading() % 90);
		while (true) {
			// Tell the game we will want to move ahead 40000 -- some large number
			setAhead(40000);
			movingForward = true;
			// Tell the game we will want to turn right 90
			setTurnRight(90);
			// At this point, we have indicated to the game that *when we do something*,
			// we will want to move ahead and turn right.  That's what "set" means.
			// It is important to realize we have not done anything yet!
			// In order to actually move, we'll want to call a method that
			// takes real time, such as waitFor.
			// waitFor actually starts the action -- we start moving and turning.
			// It will not return until we have finished turning.
			waitFor(new TurnCompleteCondition(this));
			// Note:  We are still moving ahead now, but the turn is complete.
			// Now we'll turn the other way...
			setTurnLeft(180);
			// ... and wait for the turn to finish ...
			waitFor(new TurnCompleteCondition(this));
			// ... then the other way ...
			setTurnRight(180);
			// .. and wait for that turn to finish.
			waitFor(new TurnCompleteCondition(this));
			// then back to the top to do it all again
		}//while
	}//run

	/**
	 * onScannedRobot: Fire!
	 */
	public void onScannedRobot(ScannedRobotEvent e) {

		double dist = e.getDistance();
		double absBearing = e.getBearingRadians() + getHeadingRadians();                // The enemies location relative to us
		double latVel = e.getVelocity() * Math.sin(e.getHeadingRadians() - absBearing); // The enemies lateral velocity
		double radarTurn = absBearing - getRadarHeadingRadians();                       // The amount to turn our radar

		//		double HGRating = (double) HGHits / HGShots;
		//		double LGRating = (double) LGHits / LGShots;

		if (energy > (energy = e.getEnergy())) {
			enemyFireCount++;
			if (enemyFireCount % 5 == 0) {
				dir = -dir;
				if (Utils.isNear(getHeadingRadians(), 0D) || Utils.isNear(getHeadingRadians(), Math.PI)) {
					setAhead((Math.max(getBattleFieldHeight() - getY(), getY()) - 28) * dir);
				} else {
					setAhead((Math.max(getBattleFieldWidth() - getX(), getX()) - 28) * dir);
				}
			}
		}


		setMaxVelocity(Math.random() * 12);


		double enemyEnergy = e.getEnergy();
		double bulletPower = Math.min(3, enemyEnergy / 4);
		if(enemyEnergy < 16 && enemyEnergy > 4)
		{
			bulletPower = (enemyEnergy + 2) / 4;
		} else if(enemyEnergy < 4)
			bulletPower = enemyEnergy / 4;

		setTurnGunRightRadians(Utils.normalRelativeAngle(absBearing - getGunHeadingRadians() + Math.asin(latVel / (20 - 3 * bulletPower))));
		setFire(bulletPower); // Fire the minimum amount of energy needed to finish off the other robot
		setTurnRadarRightRadians(Utils.normalRelativeAngle(radarTurn) * 2); // Make the radar lock on
	}

	public void onHitWall(HitWallEvent e) {
		// Bounce off!
		reverseDirection();
	}

	/**
	 * reverseDirection:  Switch from ahead to back & vice versa
	 */
	public void reverseDirection() {
		if (movingForward) {
			setBack(40000);
			movingForward = false;
		} else {
			setAhead(40000);
			movingForward = true;
		}
	}
}
